\documentclass[11pt,a4paper,oneside,oldfontcommands]{ctexart}
\usepackage{tabularx}
\usepackage{array}
\usepackage{bm}
\usepackage{hyperref}
\usepackage{graphicx} 
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{fancyhdr}
\pagestyle{fancy}
\usepackage{color}
\usepackage{xcolor}
\definecolor{keywordcolor}{rgb}{0.8,0.1,0.5}
\usepackage{listings}


\definecolor{mygreen}{rgb}{0,0.6,0}  
\definecolor{mygray}{rgb}{0.5,0.5,0.5}  
\definecolor{mymauve}{rgb}{0.58,0,0.82}  
  
\lstset{ %  
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}  
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code  
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace  
  breaklines=true,                 % sets automatic line breaking  
  captionpos=bl,                    % sets the caption-position to bottom  
  commentstyle=\color{mygreen},    % comment style  
  deletekeywords={...},            % if you want to delete keywords from the given language  
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code  
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8  
  frame=single,                    % adds a frame around the code  
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)  
  keywordstyle=\color{blue},       % keyword style  
  %language=Python,                 % the language of the code  
  morekeywords={*,...},            % if you want to add more keywords to the set  
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)  
  numbersep=5pt,                   % how far the line-numbers are from the code  
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers  
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))  
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'  
  showstringspaces=false,          % underline spaces within strings only  
  showtabs=false,                  % show tabs within strings adding particular underscores  
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered  
  stringstyle=\color{orange},     % string literal style  
  tabsize=2,                       % sets default tabsize to 2 spaces  
  %title=myPython.py                   % show the filename of files included with \lstinputlisting; also try caption instead of title  
}  
\hypersetup{hypertex=true,
	colorlinks=true,
	linkcolor=red,
	anchorcolor=blue,
	citecolor=blue}
\fancyhf{}
\chead{\textbf{算法设计与分析}}
\fancyhead[r]{\bfseries\thepage}
\fancyhead[l]{\bfseries\rightmark}
\renewcommand{\headrulewidth}{0.4pt} % 注意不用 \setlength
\renewcommand{\footrulewidth}{0pt}

\floatname{algorithm}{算法}
\renewcommand{\algorithmicrequire}{\textbf{输入:}}
\renewcommand{\algorithmicensure}{\textbf{输出:}}

\begin{titlepage}
	\title{\Huge\textbf{算法设计与分析 作业五}\\}
	\author{\Large\textbf{作者}：吴润泽 \and{\Large\textbf{学号}：181860109}\\
	\\
	\and {\Large\textbf{Email}：\href{mailto:181860109@smail.nju.edu.cn}{181860109@smail.nju.edu.cn}}\\}
	\date{\Large\today}
\end{titlepage}
\begin{document}
\maketitle

\tableofcontents
\cleardoublepage
\section*{Chapter 13}
\markright{Chapter 13}
\addcontentsline{toc}{section}{Chapter 13}
{\subsection*{problem 13.1}}
\markright{problem 13.1}
\addcontentsline{toc}{subsection}{problem 13.1}
\subsubsection*{1)}
\begin{lstlisting}[language=C++,title=FloydNext.func]
FloydNext(G):
	D(0):=W /*初始情况下，两点间的最短路径长度就是它们的边权*/
	for(i:=1 to n):
		for(j:=1 to n):
			if map[i][j]!=Inf: /*如果ij间有边连接，则i的后继即为j*/
				GO[i][j]=j
	for(k:=1 to n):
		for(i:=1 to n):
			for(j:=1 to n):
				if D[i][j]>D[i][k]+D[k][j]:
					GO[i][j]=k /*如果i到j通过k的路径更短，则更新路由表*/
					D[i][j]=D[i][k]+D[k][j]
\end{lstlisting}
\paragraph*{2)}
算法更新路径$i \rightarrow k \rightarrow j$，所选择的j的前驱与
从选择的节点k到节点j的一条中间节点取自集合$\{1,2,\cdots,k-1\}$的最短路径上的前驱是一样的。

\begin{lstlisting}[language=C++,title=FloydPrev.func]
FloydPrev(G):
	D(0):=W
	for(i:=1 to n):
		for(j:=1 to n):
			if map[i][j]!=Inf: /*如果ij间有边连接，则j的前驱即为i*/
				GO[i][j]:=i
	for(k:=1 to n):
		for(i:=1 to n):
			for(j:=1 to n):
				if D[i][j]>D[i][k]+D[k][j]:
					GO[i][j]:=GO[k][j] /*如果i到j通过k的路径更短，则前缀为Back[k][j]*/
					D[i][j]:=D[i][k]+D[k][j]
\end{lstlisting}
{\subsection*{problem 13.2}}
\markright{problem 13.2}
\addcontentsline{toc}{subsection}{problem 13.2}
\paragraph*{1)}仿照Dijkstra算法，记录每条路径的最小值即可。
\begin{lstlisting}[language=C++,title=DijkstraCap.func]
DijkstraCap(G):
	initialize the priority queue Fringe as empty
	insert some node v to Fringe
	cap:=[] /*cap 原来存放s到达其他点的吞吐量*/
	while Fringe!=empty:
		v:=Fringe.EXTRACT-MIN()
		cap[v]:=v.priority /*存放到达v的结果*/
		UPDATE-FRINGE(v,Fringe)
	return cap
UPDATE-FRINGE(v,Fringe):
	for neighbor w of v:
		w.priority:=min(vw.weight,v.priority) 
		/*取路径的最小值，即当前路径已知吞吐量*/
		if w is UNSEEN: /*如果是第一次遍历到*/
			Fringe.INSERT(w,w.priority)  /*将w加入队列*/
		else:
			Fringe.decrease(w,w.priority) /*将w的权值更新为w.priority*/
\end{lstlisting}
\paragraph*{2)}仿照Floyd算法，对路径$i \rightarrow k \rightarrow j$从ij，ik，kj中选取最小权边即可。
\begin{lstlisting}[language=C++,title=FloydCap.func]
FloydCap(G):
D(0):=W /*开始的吞吐量记为相连边的边权值*/
for(k:=1 to n):
	for(i:=1 to n):
		for(j:=1 to n):
			D[i][j]:=min(D[i][j],D[i][k],D[k][j]) /*选取3者的最小值，作为最大吞吐量*/
\end{lstlisting}
\newpage
{\subsection*{problem 13.7}}
\markright{problem 13.7}
\addcontentsline{toc}{subsection}{problem 13.7}
计算出所有点到达$v_0$的最短路径和$v_0$到达其他顶点的最短路径。则$uv$间的最短路径即为
$u$到$v_0$的最短路径加上$v$到$v_0$的最短路径。
\begin{lstlisting}[language=C++,title=ShortByV.func]
ShortByV(G,v):
	D:=W /*初始化所有最短路径为起始结点权值*/
	for(k:=1 to n): /*计算所有节点到达v的最短路径*/
		for(i:=1 to n):
			D[i][v]:=min(D[i][v],D[i][k]+D[k][v])
	for(k:=1 to n): /*计算v到达所有节点的最短路径*/
		for(i:=1 to n):
			D[v][i]:=min(D[v][i],D[v][k]+D[k][i])
	for(i:=1 to n):
		for(j:=1 to n):
			D[i][j]:=D[i][v]+D[v][j] /*最短路径为i到v加v到j的最短路径*/
\end{lstlisting}
\section*{Chapter 14}
\markright{Chapter 14}
\addcontentsline{toc}{section}{Chapter 14}
{\subsection*{problem 14.2}}
\markright{problem 14.2}
\addcontentsline{toc}{subsection}{problem 14.2}
{\subsection*{problem 14.3}}
\markright{problem 14.3}
\addcontentsline{toc}{subsection}{problem 14.3}
{\subsection*{problem 14.6}}
\markright{problem 14.6}
\addcontentsline{toc}{subsection}{problem 14.6}
{\subsection*{problem 14.7}}
\markright{problem 14.7}
\addcontentsline{toc}{subsection}{problem 14.7}
{\subsection*{problem 14.11}}
\markright{problem 14.11}
\addcontentsline{toc}{subsection}{problem 14.11}
{\subsection*{problem 14.13}}
\markright{problem 14.13}
\addcontentsline{toc}{subsection}{problem 14.13}
{\subsection*{problem 14.14}}
\markright{problem 14.14}
\addcontentsline{toc}{subsection}{problem 14.14}
\end{document}





