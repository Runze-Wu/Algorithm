\documentclass[11pt]{ctexart}
\usepackage{tabularx}
\usepackage{array}
\usepackage{bm}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{algorithm}
%\usepackage{algorithm2e}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{fancyhdr}
\pagestyle{fancy}

\hypersetup{hypertex=true,
	colorlinks=true,
	linkcolor=red,
	anchorcolor=blue,
	citecolor=blue}
\fancyhf{}
\chead{\textbf{算法设计与分析}}
\fancyhead[r]{\bfseries\thepage}
\fancyhead[l]{\bfseries\rightmark}
\renewcommand{\headrulewidth}{0.4pt} % 注意不用 \setlength
\renewcommand{\footrulewidth}{0pt}

\floatname{algorithm}{算法}
\renewcommand{\algorithmicrequire}{\textbf{输入:}}
\renewcommand{\algorithmicensure}{\textbf{输出:}}

\begin{titlepage}
	\title{\Huge\textbf{算法设计与分析 作业二}\\}
	\author{\Large\textbf{作者}：吴润泽 \and{\Large\textbf{学号}：181860109}\\
	\\
	\and {\Large\textbf{Email}：181860109@smail.nju.edu.cn}\\}
	\date{\Large\today}
\end{titlepage}

\begin{document}
	\maketitle

	\tableofcontents
		\newpage
	\section*{PART I}
	\markright{PART I}
	\addcontentsline{toc}{section}{PART I}
	\subsection*{problem 6.8}
	\markright{problem 6.8}
	\addcontentsline{toc}{subsection}{problem 6.8}
		
	\paragraph{算法分析}假定n总是k的倍数，且n和k都是2的幂。\\
	\hspace*{20pt}利用快排的思想，将数组从中间划分为两段$A[0\cdots n/2],\ A[n/2+1\cdots n]$，且左段元素小于右段元素。\\
	\hspace*{20pt}对于子序列继续递归划分，得到$A[0\cdots n/2^m],A[n/2^m+1\cdots n/2^{m-1}]\cdots A[n-n/2^m+1\cdots n]$，当$2^m=k\rightarrow m=\log k$时，划分完成。\\
	\hspace*{20pt}因此寻找中位数划分的函数时间复杂度应为$O(n)$，划分函数的递归方程为$W(n)=2W(n/2)+O(n)$，划分左右子段$\log k$次，方能使得总的时间复杂度达到$O(n\log k)$。
	\paragraph{具体算法实现请见算法k-sorted：算法~\ref{k-sorted}}
	\paragraph{算法时间复杂度}
	对于findk\_pos，每次递归代价为$O(n)$，每次子问题缩小为原来一半的规模，且子问题只有一个，可列出递归方程为$T(n)=T(n/2)+O(n)$，由主定理可以得出$T(n)=O(n)$。\\
	\hspace*{20pt}对于k\_sorted，每次递归代价为$O(n)$，每次子问题缩小为原来一半，而需要划分左右两序列，子问题为两个，可列出递归方程为$W(n)=2W(n/2)+O(n)$，注意结束条件为递归调用了$\log k$层，每层代价均为$O(n)$，因此时间复杂度为$O(n\log k)$满足题目要求。
	
	\begin{algorithm}
		\caption{k-sorted算法}
		\label{k-sorted}
		\begin{algorithmic}[1]
			\Require 待划分序列$A[1\cdots n]$，划分段数$k$
			\Ensure 划分后的的序列$A$
			\Function{findk\_pos}{$A,k\_pos,begin,end$} \verb|\\|返回该段数组第k小\\
			\verb|/*|
			利用快排思想，选定一个key，将大于key的元素放在其右边，小于key放于左边。\\
			判断key插入的位置是否为k，如果是则函数返回，如果插入位置大于k说明第k小位于左子序列对左边递归寻找，否则对右子序列递归寻找。
			\verb|*/|
			\State $split \gets begin,key \gets A[begin]$
			\For{$i\gets begin+1\ to\ end$}
				\State {$A[i]\leq key\ ?\ swap(A[++split],A[i])$}
			\EndFor
			\State{$split>k\_pos\ ?\ \Return\ findk\_pos(A,k\_pos,begin,split-1)$}
			\State{$split<k\_pos\ ?\ \Return\ findk\_pos(A,k\_pos,split+1,end)$}
			\State \Return{$split$}
			\EndFunction
			\Function {K\_SORTED}{$A,begin,end,k,count=1$}\\
			\verb|/*|
			count记录当前的段数,每次调用findk\_pos，A被分为[begin,mid]和[mid+1,end]两段，段数变为原来两倍，且左段元素小于右段，调用层数达到logk层算法结束，否则继续划分左右子序列
			\verb|*/|
			\State{$mid\gets (end-begin)/2+begin,count\gets count*2$}
			\State{$findk\_pos(A,mid,begin,end)$}
			\If{$count==k$}\\划分k段，算法结束
			\State \Return{$A$}
			\EndIf
			\State{$k\_sorted(A,begin,mid,k,count)$}
			\State{$k\_sorted(A,mid+1,end,k,count)$}
			\EndFunction
		\end{algorithmic}
	\end{algorithm}

	\newpage
	\subsection*{problem 6.9}
	\markright{problem 6.9}
	\addcontentsline{toc}{subsection}{problem 6.9}
	\paragraph{算法分析}同样利用快速排序的思想，令螺钉为A，螺母为B：\\
	\hspace*{20pt}1. 在A数组中拿一个，根据A和螺母的大小关系，可以分成三部分，B1：比螺钉小的，B2：比螺钉大的，B3：完全匹配的。\\
	\hspace*{20pt}2. 用B3，同样可以把A分为三部分，A1：比螺母小的，A2：比螺母大的，A3：完全匹配的。\\
	\hspace*{20pt}3. B1与A1匹配，B2与A2匹配，分别执行上述算法，直至全部匹配。
	\paragraph{具体算法实现请见算法match：算法~\ref{match算法}}
	\paragraph{算法时间复杂度}对于每次递归代价：\\
	\hspace*{20pt}1. 首先寻找分割点，遍历了一次数组，时间复杂度为$O(n)$。\\
	\hspace*{20pt}2. 之后根据分割点遍历A,B两数组将其分为两部分，时间复杂度为$O(n)$。\\
	\hspace*{20pt}3. 最后将分割后两序列进行递归操作继续划分。因此每次递归操作总的代价为$O(n)$。\\
	\hspace*{20pt}因此可推得算法的递推方程为$T(n)=2T(n/2)+O(n)$。根据主定理可得时间复杂度为$O(n\log n)$满足题目要求。
	\begin{algorithm}
		\caption{match算法}
		\label{match算法}
		\begin{algorithmic}[1]
			\Require 螺钉数组$A$，螺母数组$B$
			\Ensure 螺钉螺母对应下标一一匹配后的数组
			\Function{MATCH}{$A,B,l,r$}\\
			\verb|/*|找到分割点，mark记录B等于A首元素的下标，\\
			count记录B中小于A的个数\verb|*/|
			\State {$count \gets 0, mark\gets 0$}
			\For{$i\gets l \ to\ r$}
			\State{$A[l]==B[i]\ ?\ mark=i$}
			\State{$A[l]>B[i]\ ?\ count+=1$}
			\EndFor\\
			\verb|/*|为B和A的左半部分分配count个元素\verb|*/|
			\State{$swap(A[l],A[l+count]),\ swap(B[mark],B[l+count])$} 
			\State{$mark\gets mark+count, i\gets l,\ j \gets r$}
			\While{$i<mark$\ \textbf{and}\ $j>mark$}\verb|\\|将a分成两部分
			\While{$i<mark$\ \textbf{and}\ $a[i]<b[mark]$}\State{$i\gets i+1$}
			\EndWhile
			\While{$j>mark$\ \textbf{and}\ $a[j]<b[mark]$}\State{$j\gets j-1$}
			\EndWhile
			\State{$swap(a[i++],a[j--])$}
			\EndWhile
			
			\State{$i\gets l,\ j \gets r$}
			\While{$i<mark$\ \textbf{and}\ $j>mark$}\verb|\\|将b分成两部分
			\While{$i<mark$\ \textbf{and}\ $b[i]<a[mark]$}\State{$i\gets i+1$}
			\EndWhile
			\While{$j>mark$\ \textbf{and}\ $b[j]<a[mark]$}\State{$j\gets j-1$}
			\EndWhile
			\State{$swap(b[i++],b[j--])$}
			\EndWhile
			\State{$l<mark\ ? \ match(A,B,l,mark-1)$}
			\State{$r<mark\ ? \ match(A,B,mark+1,r)$}
			\EndFunction
		\end{algorithmic}
	\end{algorithm}
	\newpage
	\subsection*{problem 6.10}
	\markright{problem 6.10}
	\addcontentsline{toc}{subsection}{problem 6.10}
	\subsubsection*{(1)}
	\paragraph{算法分析}利用归并排序的思想，在归并排序中合并左右数组A，B\\
	\hspace*{20pt}1. 由归并排序定义可知，A、B两数组已经有序。\\
	\hspace*{20pt}2. 在合并过程中，就需要计算a[i]，b[j]分别来自左右两部分的逆序对数，同时遍历两个数组，对于遍历的两个数进行比较大小，如果$a[i]<b[0]$显然没有逆序。\\
	\hspace*{20pt}4. 如果$a[i]>b[j]$，那么$a[i+1\cdots n]>b[j]$均成立，即逆序对数有$n-i+1$个
	因此遍历时没遇到$a[i]>b[j]$，逆序对数加$n-i+1$即可。
	\paragraph{具体算法实现请见算法MergeSort：算法~\ref{MergeSort算法}}
	\paragraph{算法时间复杂度}与归并排序算法相同，在合并函数中仅添加一条赋值语句，复杂度仍为$O(n\log n)$符合题目要求。
	\subsubsection*{(2)}
	\paragraph{算法分析}同样利用归并排序的思想，在归并排序中合并左右数组A，B\\
	\hspace*{20pt}1. 同样若$a[i]<b[j]$必不存在广义逆序，而对于$a[i]>b[j]\&a[i]>C\cdot b[j]$，那么$a[i+1\cdots n]>C\cdot b[j]$均成立，与算法~\ref{MergeSort算法}\ 相似。
	\paragraph{具体算法实现}
	在算法~\ref{MergeSort算法}\ 合并操作(算法第24行)中添加判断条件：\\
	若满足{$L[i]>C\cdot R[j-1]$则$sum\gets sum+n1-i+1$即可。
	\paragraph{算法时间复杂度}与算法~\ref{MergeSort算法}\ 相同，复杂度仍为$O(n\log n)$。
	\begin{algorithm}
		\caption{MergeSort算法}
		\label{MergeSort算法}
		\begin{algorithmic}[1]
			\Require 无序序列$A,l,r$
			\Ensure  总逆序对数和$sum$
			\State{$sum\gets 0$}
			\Function {MERGESORT}{$A,l,r$}
			\State{$l==r\ ?\ \Return{}$}
			\State{$mid\gets \frac{l+r}{2}$}
			\State{$MergeSort(A,l,mid),\ MergeSort(A,mid+1,r)$}
			\State{$Merge(A,l,mid,r)$}
			\EndFunction
			\Function{Merge}{$A,l,mid,r$}
			\State{$n1\gets mid-l+1,\ n2\gets r-mid$}\\
			\verb|Let L[1..(n1+1)] and R[1..(n2+1)] be new arrays|
			\For{$i\gets\ to\ n1$}
			\State{$L[i]\gets A[l-i+1]$}
			\EndFor
			\For{$i\gets\ to\ n2$}
			\State{$R[i]\gets A[mid+i]$}
			\EndFor
			\State{$L[n1+1]\gets \infty,\ R[n2+1]\gets \infty$}
			\State{$i\gets 1,\ j\gets 1$}
			\For{$k\gets l\ to\ r$}
				\If{$L[i]<R[j]$}
				\State{$A[k]\gets L[i++]$}
				\Else
				\State{$A[k]\gets R[j++]$}
				\State{$sum\gets sum+n1-i+1$}\verb|\\|仅添加这句，更新sum逆序对和
				\EndIf
			\EndFor
			\EndFunction
		\end{algorithmic}
	\end{algorithm}
	\newpage
	\subsection*{problem 6.13}
	\markright{problem 6.13}
	\addcontentsline{toc}{subsection}{problem 6.13}
	\subsubsection*{(1)}
	\paragraph{\textcircled{1}证明}易知当R中元素个数为13倍数相同元素均为k个，则R中存在13个常见元素。假设可以有14个常见元素：则这14个常见元素个数总和$sum>=14\cdot\lceil\frac{n}{13}\rceil>n$，与总元素个数为n矛盾。\\
	因此R中存在最多13个不同的常见元素，证毕。
	\paragraph{\textcircled{2}证明}x为$R[1..n]$中常见元素，则设x在$R[1..\lfloor\frac{n}{2}\rfloor]$中有$k_1$个，在$R[\lfloor\frac{n}{2}\rfloor+1..n]$中有$k_2$个，则$k_1+k_2>=\lceil\frac{n}{13}\rceil$，假设x在两个数组中均不为常见元素，则$k_1<\lceil\frac{n}{26}\rceil,\ k_2<\lceil\frac{n}{26}\rceil$，即$k_1+k_2<2\cdot\lceil\frac{n}{26}\rceil<\lceil\frac{n}{13}\rceil$，产生矛盾，因此x至少是两个数组中一个数组的常见元素。
	\paragraph{\textcircled{3}算法设计}
	\subsubsection*{(2)}
	\subsubsection*{(3)}
	\textbf{存在}\\
	$
	\label{Majority算法}
	\begin{aligned}
	\hline
	&\textbf{算法5 }Majority\text{ 算法}\\
	\hline
	&1.\textbf{Function}\ Majority\ (A[1\cdots n])\\
	&2.\hspace*{20pt}res\gets A[1],\ count\gets1\\
	&3.\hspace*{20pt}\textbf{for}\ i\gets 2\ to\ n\ do\\
	&4.\hspace*{40pt}\textbf{if}\ res==A[i]\ do\ count\gets count+1\\
	&5.\hspace*{40pt}\textbf{else if}\ count==0\ do\ res\gets A[i], count\gets1\\
	&6.\hspace*{40pt}\textbf{else}\ count\gets count-1\\
	&7.\hspace*{20pt}count\gets 1\\
	&8.\hspace*{20pt}\textbf{for}\ i\gets 1\ to\ n\ do\\
	&9.\hspace*{40pt}\textbf{if}\ res==A[i]\ do\ count\gets count+1\\
	&10.\hspace*{20pt}\textbf{return}\ count\geq\lceil\frac{n}{2}\rceil\ ?\ res\ :\ 0\\
	\hline
	\end{aligned}
	$
	\subsubsection*{(4)}
	
	\subsection*{problem 6.15}
	\markright{problem 6.15}
	\addcontentsline{toc}{subsection}{problem 6.15}
	\newpage
	\section*{PART II}
	\markright{PART II}
	\addcontentsline{toc}{section}{PART II}
	\subsection*{problem 7.1}
	\markright{problem 7.1}
	\addcontentsline{toc}{subsection}{problem 7.1}
	\newpage
	\subsection*{problem 7.2}
	\markright{problem 7.2}
	\addcontentsline{toc}{subsection}{problem 7.2}
	\subsection*{problem 7.3}
	\markright{problem 7.3}
	\addcontentsline{toc}{subsection}{problem 7.3}
	\subsection*{problem 7.4}
	\markright{problem 7.4}
	\addcontentsline{toc}{subsection}{problem 7.4}
	\subsection*{problem 7.6}	
	\markright{problem 7.6}
	\addcontentsline{toc}{subsection}{problem 7.6}
\end{document}